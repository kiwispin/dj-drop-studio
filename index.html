<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DJ Drop Studio</title>
    <style>
        /* === DJ DROP STUDIO - PROFESSIONAL REDESIGN === */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');

        /* --- DESIGN TOKENS --- */
        :root {
            --bg: #0a0a0a;
            --panel: rgba(22, 22, 22, 0.9);
            --surface: #1a1a1a;
            --card: rgba(26, 26, 26, 0.8);
            --border: rgba(255, 255, 255, 0.08);
            --border-hover: rgba(255, 255, 255, 0.15);

            /* Accent Colors */
            --intro: #22c55e;
            --intro-glow: rgba(34, 197, 94, 0.3);
            --voice: #d946ef;
            --voice-glow: rgba(217, 70, 239, 0.3);
            --outro: #a855f7;
            --outro-glow: rgba(168, 85, 247, 0.3);
            --master: #06b6d4;
            --master-glow: rgba(6, 182, 212, 0.3);
            --action: #f97316;
            --action-glow: rgba(249, 115, 22, 0.4);

            /* Text */
            --text: #f3f4f6;
            --text-dim: #888888;
            --text-muted: #555555;

            /* Sizing */
            --radius: 12px;
            --radius-sm: 8px;
        }

        * {
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            background: var(--bg);
            color: var(--text);
            margin: 0;
            padding: 0;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        /* === MAIN LAYOUT === */
        .studio-container {
            display: grid;
            grid-template-columns: 260px 1fr;
            gap: 16px;
            padding: 16px;
            flex: 1;
            max-width: 1400px;
            margin: 0 auto;
            width: 100%;
            min-height: 0;
        }

        /* === SIDEBAR === */
        .sidebar {
            background: var(--panel);
            backdrop-filter: blur(20px);
            border: 1px solid var(--border);
            border-radius: var(--radius);
            padding: 16px;
            display: flex;
            flex-direction: column;
            position: sticky;
            top: 16px;
            height: calc(100vh - 32px);
            overflow: hidden;
        }

        .tabs {
            display: flex;
            gap: 4px;
            margin-bottom: 16px;
            background: rgba(0, 0, 0, 0.3);
            padding: 4px;
            border-radius: var(--radius-sm);
        }

        .tab {
            flex: 1;
            padding: 10px 12px;
            text-align: center;
            background: transparent;
            color: var(--text-dim);
            cursor: pointer;
            border-radius: 6px;
            font-size: 0.75rem;
            text-transform: uppercase;
            font-weight: 600;
            letter-spacing: 0.05em;
            transition: all 0.2s ease;
        }

        .tab:hover {
            color: var(--text);
            background: rgba(255, 255, 255, 0.05);
        }

        .tab.active {
            color: var(--master);
            background: rgba(6, 182, 212, 0.15);
        }

        .tab-content {
            flex: 1;
            overflow-y: auto;
            display: none;
        }

        .tab-content.active {
            display: flex;
            flex-direction: column;
        }

        .crate-header {
            font-size: 0.7rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: var(--text-muted);
            margin-bottom: 12px;
            padding-left: 4px;
        }

        /* Drop Zone */
        .drop-zone {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            border: 2px dashed rgba(255, 255, 255, 0.1);
            border-radius: var(--radius-sm);
            padding: 20px 16px;
            text-align: center;
            font-size: 0.8rem;
            color: var(--text-dim);
            cursor: pointer;
            transition: all 0.2s ease;
            background: rgba(0, 0, 0, 0.2);
            margin-bottom: 12px;
        }

        .drop-zone:hover {
            border-color: var(--master);
            color: var(--text);
            background: rgba(6, 182, 212, 0.05);
        }

        /* Voice List */
        .voice-list {
            list-style: none;
            padding: 0;
            margin: 0;
            flex: 1;
            overflow-y: auto;
        }

        .voice-item {
            background: rgba(255, 255, 255, 0.03);
            padding: 10px 12px;
            margin-bottom: 4px;
            border-radius: 6px;
            cursor: pointer;
            border: 1px solid transparent;
            font-size: 0.8rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: all 0.15s ease;
        }

        .voice-item:hover {
            background: rgba(255, 255, 255, 0.06);
            border-color: var(--border);
        }

        .voice-item.active {
            border-color: var(--voice);
            background: rgba(217, 70, 239, 0.1);
        }

        /* Cloud Items */
        .cloud-item {
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid var(--border);
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .cloud-item:hover {
            border-color: var(--master);
        }

        .cloud-name {
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            font-size: 0.8rem;
        }

        .cloud-actions {
            display: flex;
            gap: 4px;
        }

        .lib-btn {
            background: rgba(255, 255, 255, 0.08);
            border: none;
            color: var(--text-dim);
            padding: 5px 8px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.7rem;
            transition: all 0.15s ease;
        }

        .lib-btn:hover {
            background: var(--voice);
            color: #fff;
        }

        .preview-btn:hover {
            background: var(--intro);
        }

        .delete-btn:hover {
            background: #ef4444;
        }

        /* === MAIN MIXER AREA === */
        .mixer {
            display: flex;
            flex-direction: column;
            gap: 12px;
            min-height: 0;
        }

        /* Header */
        .header-section {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 0;
        }

        h1 {
            margin: 0;
            font-size: 1.4rem;
            font-weight: 700;
            letter-spacing: -0.02em;
            background: linear-gradient(135deg, var(--text) 0%, var(--text-dim) 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        /* === TRACK CARDS === */
        .track {
            background: var(--card);
            backdrop-filter: blur(10px);
            border: 1px solid var(--border);
            border-radius: var(--radius);
            padding: 16px 20px;
            position: relative;
            transition: all 0.2s ease;
        }

        .track:hover {
            border-color: var(--border-hover);
        }

        .track-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }

        .track-title {
            font-weight: 600;
            font-size: 0.8rem;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            color: var(--text-dim);
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .track-number {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 22px;
            height: 22px;
            border-radius: 50%;
            font-size: 0.7rem;
            font-weight: 700;
        }

        /* Track accent colors */
        .track-intro {
            border-left: 3px solid var(--intro);
        }

        .track-intro .track-number {
            background: var(--intro-glow);
            color: var(--intro);
        }

        .track-voice {
            border-left: 3px solid var(--voice);
        }

        .track-voice .track-number {
            background: var(--voice-glow);
            color: var(--voice);
        }

        .track-outro {
            border-left: 3px solid var(--outro);
        }

        .track-outro .track-number {
            background: var(--outro-glow);
            color: var(--outro);
        }

        .track-master {
            border-left: 3px solid var(--master);
        }

        .track-master .track-number {
            background: var(--master-glow);
            color: var(--master);
        }

        /* Track Row Layout */
        .track-row {
            display: flex;
            gap: 20px;
            align-items: center;
        }

        .track-col-left {
            flex: 1;
        }

        .track-col-right {
            flex: 1;
        }

        /* === TOP ROW: INTRO + OUTRO side by side === */
        .top-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
        }

        /* Compact file input styling */
        .file-input-wrapper {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .file-btn {
            background: rgba(255, 255, 255, 0.06);
            border: 1px solid var(--border);
            color: var(--text-dim);
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.75rem;
            font-weight: 500;
            transition: all 0.15s ease;
            white-space: nowrap;
        }

        .file-btn:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: var(--border-hover);
            color: var(--text);
        }

        .file-status {
            font-size: 0.75rem;
            color: var(--master);
            font-weight: 500;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .file-status:empty::after {
            content: 'No file loaded';
            color: var(--text-muted);
        }

        /* Hidden native file input */
        input[type="file"] {
            display: none;
        }

        /* === FX CARDS (Voice Core) === */
        .fx-section {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 12px;
        }

        .fx-card {
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid var(--border);
            border-radius: var(--radius-sm);
            padding: 14px;
        }

        .fx-head {
            font-size: 0.7rem;
            color: var(--voice);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-bottom: 12px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .fx-head span {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        /* === CONTROLS === */
        .control-group {
            margin-bottom: 10px;
        }

        .control-group:last-child {
            margin-bottom: 0;
        }

        .control-header {
            display: flex;
            justify-content: space-between;
            font-size: 0.7rem;
            color: var(--text-dim);
            margin-bottom: 6px;
        }

        .val-display {
            color: var(--master);
            font-family: 'Inter', monospace;
            font-weight: 600;
            font-size: 0.7rem;
        }

        .param-text-row {
            display: flex;
            justify-content: space-between;
            font-size: 0.7rem;
            color: var(--text-muted);
            margin-bottom: 6px;
        }

        /* === CUSTOM RANGE SLIDERS === */
        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            height: 6px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
            outline: none;
            cursor: pointer;
        }

        input[type="range"]::-webkit-slider-track {
            background: linear-gradient(90deg,
                    var(--master) 0%,
                    rgba(255, 255, 255, 0.1) 100%);
            height: 6px;
            border-radius: 3px;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #fff;
            cursor: pointer;
            box-shadow: 0 0 10px var(--master-glow), 0 2px 4px rgba(0, 0, 0, 0.3);
            transition: transform 0.15s ease, box-shadow 0.15s ease;
        }

        input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.15);
            box-shadow: 0 0 16px var(--master-glow), 0 2px 6px rgba(0, 0, 0, 0.4);
        }

        input[type="range"]::-moz-range-track {
            background: rgba(255, 255, 255, 0.1);
            height: 6px;
            border-radius: 3px;
        }

        input[type="range"]::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #fff;
            cursor: pointer;
            border: none;
            box-shadow: 0 0 10px var(--master-glow);
        }

        /* Checkbox styling */
        input[type="checkbox"] {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border: 2px solid var(--border);
            border-radius: 4px;
            cursor: pointer;
            position: relative;
            transition: all 0.15s ease;
        }

        input[type="checkbox"]:checked {
            background: var(--voice);
            border-color: var(--voice);
        }

        input[type="checkbox"]:checked::after {
            content: '‚úì';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 12px;
            font-weight: bold;
        }

        /* === CLOUD SHARE BUTTONS (in Track Headers) === */
        .cloud-btn {
            background: rgba(255, 255, 255, 0.06);
            color: var(--text-dim);
            border: 1px solid var(--border);
            padding: 6px 12px;
            font-size: 0.7rem;
            border-radius: 6px;
            cursor: pointer;
            display: none;
            align-items: center;
            gap: 6px;
            font-weight: 500;
            transition: all 0.15s ease;
        }

        .cloud-btn:hover {
            background: var(--master);
            color: #000;
            border-color: var(--master);
        }

        .cloud-btn svg {
            width: 12px;
            height: 12px;
            fill: currentColor;
        }

        /* === STICKY ACTION BAR === */
        .action-bar {
            position: sticky;
            bottom: 0;
            left: 0;
            right: 0;
            background: linear-gradient(to top, var(--bg) 0%, var(--bg) 60%, transparent 100%);
            padding: 20px 16px 16px;
            margin-top: auto;
        }

        .transport {
            background: var(--panel);
            backdrop-filter: blur(20px);
            padding: 16px 20px;
            border-radius: var(--radius);
            border: 1px solid var(--border);
            display: flex;
            gap: 16px;
            align-items: center;
            max-width: 1400px;
            margin: 0 auto;
        }

        /* Visualizer */
        .viz-container {
            flex: 1;
            height: 44px;
            background: rgba(0, 0, 0, 0.4);
            border-radius: var(--radius-sm);
            position: relative;
            overflow: hidden;
            border: 1px solid var(--border);
        }

        .viz-progress {
            position: absolute;
            top: 0;
            left: 0;
            bottom: 0;
            width: 0%;
            background: linear-gradient(90deg, var(--master-glow) 0%, transparent 100%);
            border-right: 2px solid var(--master);
            transition: width 0.1s linear;
        }

        .viz-text {
            position: absolute;
            width: 100%;
            text-align: center;
            line-height: 44px;
            font-size: 0.8rem;
            font-weight: 500;
            color: var(--text-muted);
        }

        /* === MICRO-ANIMATIONS === */

        /* 1. Tactile Button Press */
        button:active,
        .file-btn:active,
        .drop-zone:active {
            transform: scale(0.96) translateY(1px);
            filter: brightness(0.9);
        }

        /* 2. Pulse Animation for Primary Action */
        @keyframes pulse-glow {
            0% {
                box-shadow: 0 0 0 0 rgba(249, 115, 22, 0.4);
            }

            70% {
                box-shadow: 0 0 0 10px rgba(249, 115, 22, 0);
            }

            100% {
                box-shadow: 0 0 0 0 rgba(249, 115, 22, 0);
            }
        }

        .btn-gen:not(:disabled) {
            animation: pulse-glow 2s infinite;
        }

        /* 3. Reactive Faders (Glow Intensifies on Touch) */
        input[type="range"]:active::-webkit-slider-thumb {
            transform: scale(1.3);
            box-shadow: 0 0 20px var(--master-glow), 0 0 10px white;
            cursor: grabbing;
        }

        input[type="range"]:active::-moz-range-thumb {
            transform: scale(1.3);
            box-shadow: 0 0 20px var(--master-glow), 0 0 10px white;
            cursor: grabbing;
        }

        /* 4. Smooth List Item Entry */
        .voice-item,
        .cloud-item {
            /* Existing styles... */
            animation: slideIn 0.2s ease-out;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateX(-5px);
            }

            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        /* Action Buttons */
        .main-btn {
            padding: 14px 28px;
            border: none;
            border-radius: var(--radius-sm);
            font-weight: 600;
            font-size: 0.85rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 8px;
        }

        .btn-gen {
            background: linear-gradient(135deg, var(--action) 0%, #ea580c 100%);
            color: white;
            box-shadow: 0 4px 20px var(--action-glow);
        }

        .btn-gen:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 28px var(--action-glow);
        }

        .btn-gen:active {
            transform: translateY(0);
        }

        .btn-gen:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .btn-save {
            background: rgba(255, 255, 255, 0.08);
            color: var(--text);
            border: 1px solid var(--border);
        }

        .btn-save:hover {
            background: rgba(255, 255, 255, 0.12);
            border-color: var(--border-hover);
        }

        .btn-save:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        /* === UTILITY CLASSES === */
        .text-intro {
            color: var(--intro);
        }

        .text-voice {
            color: var(--voice);
        }

        .text-outro {
            color: var(--outro);
        }

        .text-master {
            color: var(--master);
        }

        /* Selected voice indicator */
        #selectedVoiceName {
            font-size: 0.85rem;
            color: var(--voice);
            font-weight: 500;
        }

        /* Cloud tags */
        .cloud-tag {
            font-size: 0.6rem;
            padding: 2px 6px;
            border-radius: 4px;
            text-transform: uppercase;
            font-weight: 600;
            letter-spacing: 0.05em;
        }

        .tag-intro {
            background: var(--intro-glow);
            color: var(--intro);
        }

        .tag-outro {
            background: var(--outro-glow);
            color: var(--outro);
        }

        /* Scrollbar styling */
        ::-webkit-scrollbar {
            width: 6px;
        }

        ::-webkit-scrollbar-track {
            background: transparent;
        }

        ::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.15);
            border-radius: 3px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 255, 255, 0.25);
        }

        /* Responsive adjustments */
        @media (max-width: 1200px) {
            .fx-section {
                grid-template-columns: repeat(2, 1fr);
            }
        }

        @media (max-width: 900px) {
            .studio-container {
                grid-template-columns: 1fr;
            }

            .sidebar {
                position: relative;
                top: 0;
                height: auto;
                max-height: 300px;
            }

            .top-row {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>

<body>

    <div class="studio-container">

        <!-- SIDEBAR -->
        <aside class="sidebar">
            <!-- TABS -->
            <div class="tabs">
                <div class="tab active" id="tabLocal">My Crate</div>
                <div class="tab" id="tabCloud" style="display:none">Cloud SFX</div>
            </div>

            <!-- LOCAL CONTENT -->
            <div id="contentLocal" class="tab-content active">
                <div class="crate-header">Local Voices</div>
                <label for="voiceUploader" class="drop-zone" id="localDropZone">
                    <div>üìÇ Click to Upload</div>
                    <div style="font-size:0.7rem; margin-top:5px; color:#555">MP3 / WAV Supported</div>
                </label>
                <input type="file" id="voiceUploader" multiple accept="audio/*" style="display:none">
                <ul class="voice-list" id="voiceList">
                    <li style="padding:15px; color:#444; font-size:0.8rem; text-align:center; font-style:italic"
                        id="emptyMsg">
                        Library Empty
                    </li>
                </ul>
                <div
                    style="margin-top:auto; padding-top:10px; border-top:1px solid #333; font-size:0.7rem; color:#666; text-align:center;">
                    Files saved to Browser Memory (IndexedDB)
                </div>
            </div>

            <!-- CLOUD CONTENT -->
            <div id="contentCloud" class="tab-content">
                <div class="crate-header">Community Library</div>
                <p style="font-size:0.7rem; color:#666; padding:0 10px;">
                    Shared SFX from other users. Click to load into Intro/Outro slots.
                </p>
                <ul class="voice-list" id="cloudList">
                    <li style="padding:15px; color:#444; font-size:0.8rem; text-align:center;">Loading...</li>
                </ul>
            </div>
        </aside>

        <!-- MAIN AREA -->
        <main class="mixer">
            <div class="header-section">
                <h1>DJ Drop Studio</h1>
            </div>

            <!-- TOP ROW: INTRO + OUTRO side by side -->
            <div class="top-row">
                <!-- 1. INTRO SFX -->
                <div class="track track-intro">
                    <div class="track-header">
                        <div class="track-title">
                            <span class="track-number">1</span>
                            Intro SFX
                        </div>
                        <button class="cloud-btn" id="uploadIntroBtn" title="Upload current Intro to Cloud Library">
                            <svg viewBox="0 0 24 24">
                                <path d="M9 16h6v-6h4l-7-7-7 7h4v6zm-4 2h14v2H5z" />
                            </svg>
                            Share
                        </button>
                    </div>
                    <div class="file-input-wrapper">
                        <label for="introFile" class="file-btn">üìÇ Load File</label>
                        <input type="file" id="introFile" accept="audio/*">
                        <div id="introStatus" class="file-status"></div>
                    </div>
                    <div class="control-group" style="margin-top: 12px;">
                        <div class="control-header">
                            <span>Volume</span>
                            <span class="val-display" id="introVolVal">0.8</span>
                        </div>
                        <input type="range" id="introVol" min="0" max="1.5" step="0.1" value="0.8">
                    </div>
                </div>

                <!-- 3. OUTRO SFX -->
                <div class="track track-outro">
                    <div class="track-header">
                        <div class="track-title">
                            <span class="track-number">3</span>
                            Outro SFX
                        </div>
                        <button class="cloud-btn" id="uploadOutroBtn" title="Upload current Outro to Cloud Library">
                            <svg viewBox="0 0 24 24">
                                <path d="M9 16h6v-6h4l-7-7-7 7h4v6zm-4 2h14v2H5z" />
                            </svg>
                            Share
                        </button>
                    </div>
                    <div class="file-input-wrapper">
                        <label for="outroFile" class="file-btn">üìÇ Load File</label>
                        <input type="file" id="outroFile" accept="audio/*">
                        <div id="outroStatus" class="file-status"></div>
                    </div>
                    <div class="track-row" style="margin-top: 12px; gap: 12px;">
                        <div class="control-group" style="flex: 1; margin: 0;">
                            <div class="control-header">
                                <span>Offset</span>
                                <span class="val-display" id="outroOffsetVal">0.0s</span>
                            </div>
                            <input type="range" id="outroOffset" min="-5" max="5" step="0.1" value="0">
                        </div>
                        <div class="control-group" style="flex: 1; margin: 0;">
                            <div class="control-header">
                                <span>Volume</span>
                                <span class="val-display" id="outroVolVal">0.8</span>
                            </div>
                            <input type="range" id="outroVol" min="0" max="1.5" step="0.1" value="0.8">
                        </div>
                    </div>
                </div>
            </div>

            <!-- 2. VOICE TRACK -->
            <div class="track track-voice">
                <div class="track-header">
                    <div class="track-title">
                        <span class="track-number">2</span>
                        Voice Core
                    </div>
                    <div id="selectedVoiceName">No Voice Selected</div>
                </div>

                <!-- PRO FX RACK -->
                <div class="fx-section">
                    <!-- Build Up -->
                    <div class="fx-card">
                        <div class="fx-head">
                            <span>üöÄ Build-Up</span>
                            <input type="checkbox" id="buildUpOn" checked>
                        </div>
                        <div class="param-text-row">
                            <span>Stutters</span>
                            <span class="text-master">4x</span>
                        </div>
                        <div class="param-text-row">
                            <span>FX Chain</span>
                            <span style="font-size:0.65rem">Pitch + Filter + Flange</span>
                        </div>
                    </div>

                    <!-- Pro Width & EQ -->
                    <div class="fx-card">
                        <div class="fx-head">
                            <span>üíé Pro Width</span>
                            <input type="checkbox" id="widthOn" checked>
                        </div>
                        <div class="control-group">
                            <div class="control-header">
                                <span>Stereo Width</span>
                                <span class="val-display" id="widthVal">50%</span>
                            </div>
                            <input type="range" id="widthAmt" min="0" max="1" step="0.1" value="0.5">
                        </div>
                        <div class="param-text-row">
                            <span>Radio EQ</span>
                            <span class="text-master">Presence + Air</span>
                        </div>
                    </div>

                    <!-- Tail FX -->
                    <div class="fx-card">
                        <div class="fx-head">
                            <span>üåå Tail FX</span>
                            <input type="checkbox" id="tailOn" checked>
                        </div>
                        <div class="control-group">
                            <div class="control-header">
                                <span>Tail Start</span>
                                <span class="val-display" id="tailStartVal">60%</span>
                            </div>
                            <input type="range" id="tailStart" min="0.1" max="0.9" step="0.1" value="0.6">
                        </div>
                        <div class="control-group">
                            <div class="control-header">
                                <span>Wet Level</span>
                                <span class="val-display" id="tailMixVal">50%</span>
                            </div>
                            <input type="range" id="tailMix" min="0" max="1" step="0.1" value="0.5">
                        </div>
                    </div>

                    <!-- Master Voice Control -->
                    <div class="fx-card">
                        <div class="fx-head">
                            <span>üéöÔ∏è Voice Level</span>
                        </div>
                        <div class="control-group">
                            <div class="control-header">
                                <span>Offset</span>
                                <span class="val-display" id="voiceOffsetVal">0.0s</span>
                            </div>
                            <input type="range" id="voiceOffset" min="-1" max="10" step="0.1" value="0">
                        </div>
                        <div class="control-group">
                            <div class="control-header">
                                <span>Volume</span>
                                <span class="val-display" id="voiceVolVal">1.0</span>
                            </div>
                            <input type="range" id="voiceVol" min="0" max="1.5" step="0.1" value="1.0">
                        </div>
                        <div class="control-group">
                            <div class="control-header">
                                <span>Pitch</span>
                                <span class="val-display" id="voicePitchVal">0st</span>
                            </div>
                            <input type="range" id="voicePitch" min="-12" max="12" step="1" value="0">
                        </div>
                        <div class="control-group">
                            <div class="control-header">
                                <span>End Trim</span>
                                <span class="val-display" id="endTrimVal">0.0s</span>
                            </div>
                            <input type="range" id="endTrim" min="-10" max="5" step="0.5" value="0">
                        </div>
                    </div>
                </div>
            </div>

            <!-- 4. MUSIC BED -->
            <div class="track track-master">
                <div class="track-header">
                    <div class="track-title">
                        <span class="track-number">4</span>
                        Music Bed
                    </div>
                    <label
                        style="font-size:0.75rem; cursor:pointer; display:flex; align-items:center; gap:6px; color: var(--text-dim);">
                        <input type="checkbox" id="autoDuck" checked> Auto-Duck
                    </label>
                </div>
                <div class="track-row">
                    <div class="file-input-wrapper" style="flex: 1;">
                        <label for="bedFile" class="file-btn">üìÇ Load Music</label>
                        <input type="file" id="bedFile" accept="audio/*">
                        <div id="bedStatus" class="file-status"></div>
                    </div>
                    <div class="control-group" style="flex: 1; margin: 0;">
                        <div class="control-header">
                            <span>Music Volume</span>
                            <span class="val-display" id="bedVolVal">0.5</span>
                        </div>
                        <input type="range" id="bedVol" min="0" max="1" step="0.1" value="0.5">
                    </div>
                </div>
            </div>

            <!-- TRANSPORT -->
            <div class="transport">
                <div class="viz-container">
                    <div class="viz-text" id="statusText">Ready to Render</div>
                    <div class="viz-progress" id="progressBar"></div>
                </div>
                <button class="main-btn btn-gen" id="generateBtn">
                    <span>‚ñ∂ Render & Play</span>
                </button>
                <button class="main-btn btn-save" id="downloadBtn" disabled>
                    <span>‚¨á Save</span>
                </button>
            </div>

        </main>
    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, collection, addDoc, onSnapshot, query, orderBy, deleteDoc, doc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        import { getStorage, ref, uploadBytes, getDownloadURL, getBlob, deleteObject } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-storage.js";

        // --- CONFIGURATION ---
        // CONNECTED TO: dji-drop-studio
        const firebaseConfig = {
            apiKey: "AIzaSyBiiOEfUnRY5tWZX8mSyvFAwnLLsK9QhH8",
            authDomain: "dji-drop-studio.firebaseapp.com",
            projectId: "dji-drop-studio",
            storageBucket: "dji-drop-studio.firebasestorage.app",
            messagingSenderId: "566870188844",
            appId: "1:566870188844:web:81ce637d5c2e92fc7e4289",
            measurementId: "G-C3XR0N1KFY"
        };

        // This ID is used to group your files in the database. 
        // Everyone using this file will see the same 'shared' folder.
        const appId = 'dji-drop-studio-main';

        let cloudEnabled = false;
        let db = null;
        let storage = null;

        // HELPER
        const $ = (id) => document.getElementById(id);

        // Initializing Audio Context (needed for some browsers)
        async function initAudio() {
            if (!ctx) {
                ctx = new (window.AudioContext || window.webkitAudioContext)();
            }
            if (ctx.state === 'suspended') {
                await ctx.resume();
            }
        }

        // --- PERSISTENT SETTINGS ---
        function saveSettings() {
            const settings = {};
            // Save all sliders
            document.querySelectorAll('input[type="range"]').forEach(input => {
                settings[input.id] = input.value;
            });
            // Save all checkboxes
            document.querySelectorAll('input[type="checkbox"]').forEach(input => {
                settings[input.id] = input.checked;
            });
            localStorage.setItem('dj-drop-settings', JSON.stringify(settings));
        }

        function loadSettings() {
            const saved = localStorage.getItem('dj-drop-settings');
            if (saved) {
                try {
                    const settings = JSON.parse(saved);
                    // Restore sliders
                    document.querySelectorAll('input[type="range"]').forEach(input => {
                        if (settings[input.id] !== undefined) {
                            input.value = settings[input.id];
                            // Trigger input event to update display values
                            input.dispatchEvent(new Event('input'));
                        }
                    });
                    // Restore checkboxes
                    document.querySelectorAll('input[type="checkbox"]').forEach(input => {
                        if (settings[input.id] !== undefined) {
                            input.checked = settings[input.id];
                            // Trigger change event if needed
                            input.dispatchEvent(new Event('change'));
                        }
                    });
                    console.log('Settings loaded from localStorage');
                } catch (e) {
                    console.error('Failed to load settings:', e);
                }
            }
        }

        // --- DOM ELEMENTS & EVENT LISTENERS ---
        const tabLocal = document.getElementById('tabLocal');
        const tabCloud = document.getElementById('tabCloud');
        const contentLocal = document.getElementById('contentLocal');
        const contentCloud = document.getElementById('contentCloud');
        const voiceUploader = document.getElementById('voiceUploader');
        const voiceList = document.getElementById('voiceList');
        const localDropZone = document.getElementById('localDropZone');

        // TABS
        tabLocal.onclick = () => { switchTab('local'); };
        tabCloud.onclick = () => { switchTab('cloud'); };

        function switchTab(tab) {
            if (tab === 'local') {
                tabLocal.classList.add('active');
                tabCloud.classList.remove('active');
                contentLocal.classList.add('active');
                contentCloud.classList.remove('active');
            } else {
                tabLocal.classList.remove('active');
                tabCloud.classList.add('active');
                contentLocal.classList.remove('active');
                contentCloud.classList.add('active');
            }
        }

        // SLIDER DISPLAYS & PERSISTENCE
        // Update number displays next to sliders and save settings
        document.querySelectorAll('input[type="range"]').forEach(input => {
            const displayId = input.id + 'Val';
            const display = document.getElementById(displayId);

            // Update display on input
            input.addEventListener('input', (e) => {
                if (display) {
                    let val = e.target.value;
                    // Format appropriately based on ID
                    if (input.id.includes('Offset') || input.id.includes('Trim')) val += 's';
                    else if (input.id.includes('Pitch')) val += 'st';
                    else if (input.id === 'widthAmt' || input.id === 'tailStart' || input.id === 'tailMix') val = Math.round(val * 100) + '%';

                    display.innerText = val;
                }
                saveSettings(); // Save on change
            });
        });

        // Save checkboxes on change
        document.querySelectorAll('input[type="checkbox"]').forEach(input => {
            input.addEventListener('change', () => {
                saveSettings();
            });
        });

        // Init settings on load
        loadSettings();

        // --- FIREBASE INIT ---
        try {
            const app = initializeApp(firebaseConfig);
            const auth = getAuth(app);
            db = getFirestore(app);
            storage = getStorage(app);

            // Init Auth
            signInAnonymously(auth).then(() => {
                console.log("Connected to Cloud Library");
                cloudEnabled = true;
                loadCloudLibrary();

                // Show Cloud UI
                document.getElementById('tabCloud').style.display = 'block';
                document.getElementById('uploadIntroBtn').style.display = 'flex';
                document.getElementById('uploadOutroBtn').style.display = 'flex';
            }).catch(e => {
                console.warn("Cloud Connection Failed:", e.message);
                // Fallback allows local use if internet/firebase fails
            });
        } catch (e) {
            console.warn("Firebase initialization failed:", e.message);
            console.log("Running in offline mode - local features still available");
            // App continues to work in local-only mode
        }

        // --- CLOUD LOGIC ---
        function loadCloudLibrary() {
            if (!cloudEnabled) return;
            const q = query(collection(db, 'artifacts', appId, 'public', 'data', 'sfx_library'));

            onSnapshot(q, (snapshot) => {
                const list = document.getElementById('cloudList');
                list.innerHTML = '';
                if (snapshot.empty) {
                    list.innerHTML = '<li style="padding:10px;text-align:center;font-size:0.8rem;color:#666">Library Empty.<br>Be the first to share!</li>';
                    return;
                }

                snapshot.forEach(docSnap => {
                    const data = docSnap.data();
                    const li = document.createElement('li');
                    li.className = 'voice-item cloud-item';

                    // Check if this is a legacy entry (no storagePath)
                    const isLegacy = !data.storagePath;

                    li.innerHTML = `
                    <button class="lib-btn preview-btn" title="Preview" ${isLegacy ? 'disabled style="opacity:0.3"' : ''}>‚ñ∂</button>
                    <span class="cloud-name" title="${data.name}" ${isLegacy ? 'style="color:#666; text-decoration:line-through;"' : ''}>${data.name}${isLegacy ? ' (old format)' : ''}</span>
                    <div class="cloud-actions">
                        <button class="lib-btn load-btn" data-slot="intro" title="Load as Intro" ${isLegacy ? 'disabled style="opacity:0.3"' : ''}>‚ÜíI</button>
                        <button class="lib-btn load-btn" data-slot="outro" title="Load as Outro" ${isLegacy ? 'disabled style="opacity:0.3"' : ''}>‚ÜíO</button>
                        <button class="lib-btn delete-btn" title="Delete">üóë</button>
                    </div>
                `;
                    // Preview button (only if has storagePath)
                    if (!isLegacy) {
                        li.querySelector('.preview-btn').onclick = (e) => {
                            e.stopPropagation();
                            previewCloudItem(data.storagePath);
                        };
                        // Load buttons
                        li.querySelectorAll('.load-btn').forEach(btn => {
                            btn.onclick = (e) => {
                                e.stopPropagation();
                                loadFromCloud(data.storagePath, data.name, btn.dataset.slot);
                            };
                        });
                    }
                    // Delete button (always works)
                    li.querySelector('.delete-btn').onclick = (e) => {
                        e.stopPropagation();
                        deleteCloudItem(docSnap.id, data.storagePath, data.name);
                    };
                    list.appendChild(li);
                });
            });
        }

        async function uploadToCloud(file, type) {
            if (!cloudEnabled) return alert("Cloud not configured.");
            if (file.size > 5000000) return alert("File too large for Cloud Library (Max 5MB).");

            try {
                // Upload file to Firebase Storage
                const fileName = `${Date.now()}_${file.name}`;
                const storageRef = ref(storage, `sfx_library/${type}/${fileName}`);
                await uploadBytes(storageRef, file);
                const downloadUrl = await getDownloadURL(storageRef);

                // Store metadata in Firestore (with storage path for CORS-safe loading)
                await addDoc(collection(db, 'artifacts', appId, 'public', 'data', 'sfx_library'), {
                    name: file.name,
                    type: type,
                    storagePath: `sfx_library/${type}/${fileName}`,
                    uploadedAt: Date.now()
                });
                alert("Uploaded to Community Library!");
                switchTab('cloud');
            } catch (err) {
                console.error(err);
                alert("Upload failed: " + err.message);
            }
        }

        async function loadFromCloud(storagePath, name, targetSlot) {
            try {
                // Use Firebase SDK's getBlob to avoid CORS issues
                const storageRef = ref(storage, storagePath);
                const blob = await getBlob(storageRef);

                if (targetSlot === 'intro') {
                    saveTrackToDB("intro", blob);
                    introBuffer = await loadAudioFile(blob);
                    $('introStatus').innerText = "Cloud: " + name;
                } else {
                    saveTrackToDB("outro", blob);
                    outroBuffer = await loadAudioFile(blob);
                    $('outroStatus').innerText = "Cloud: " + name;
                }
            } catch (err) {
                console.error('Failed to load from cloud:', err);
                alert('Failed to load file from cloud.');
            }
        }

        // Preview cloud item (play without loading)
        let previewSource = null;
        async function previewCloudItem(storagePath) {
            try {
                // Stop any existing preview
                if (previewSource) {
                    previewSource.stop();
                    previewSource = null;
                }

                const storageRef = ref(storage, storagePath);
                const blob = await getBlob(storageRef);
                const buffer = await loadAudioFile(blob);

                if (ctx.state === 'suspended') await ctx.resume();

                previewSource = ctx.createBufferSource();
                previewSource.buffer = buffer;
                previewSource.connect(ctx.destination);
                previewSource.start();
                previewSource.onended = () => previewSource = null;
            } catch (err) {
                console.error('Preview failed:', err);
                alert('Failed to preview file.');
            }
        }

        // Delete cloud item with PIN protection
        const DELETE_PIN = '1234';
        async function deleteCloudItem(docId, storagePath, name) {
            const pin = prompt(`Enter PIN to delete "${name}":`);
            if (pin !== DELETE_PIN) {
                if (pin !== null) alert('Incorrect PIN.');
                return;
            }

            try {
                // Delete from Storage (only if storagePath exists)
                if (storagePath) {
                    try {
                        const storageRef = ref(storage, storagePath);
                        await deleteObject(storageRef);
                    } catch (storageErr) {
                        console.warn('Storage delete failed (may not exist):', storageErr);
                    }
                }

                // Delete from Firestore
                await deleteDoc(doc(db, 'artifacts', appId, 'public', 'data', 'sfx_library', docId));

                alert('Deleted from library.');
            } catch (err) {
                console.error('Delete failed:', err);
                alert('Delete failed: ' + err.message);
            }
        }

        // --- AUDIO CORE ---
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        const ctx = new AudioContext();
        const dest = ctx.createMediaStreamDestination();

        // State & DB (IndexedDB for Local)
        let voiceLibrary = [];
        let selectedVoiceIndex = -1;
        let musicBuffer = null;
        let introBuffer = null;
        let outroBuffer = null;
        let recorder = null;
        let audioChunks = [];
        let reverbBuffer = null;

        // File Objects for Upload
        let currentIntroFile = null;
        let currentOutroFile = null;

        // -- INDEXEDDB --
        let idb;
        const DB_NAME = "DJDropStudioDB";
        const DB_VERSION = 1;

        function initIDB() {
            const req = indexedDB.open(DB_NAME, DB_VERSION);
            req.onupgradeneeded = (e) => {
                const db = e.target.result;
                if (!db.objectStoreNames.contains("tracks")) db.createObjectStore("tracks");
                if (!db.objectStoreNames.contains("voices")) db.createObjectStore("voices", { autoIncrement: true });
            };
            req.onsuccess = (e) => {
                idb = e.target.result;
                loadSavedAssets();
            };
        }
        initIDB();

        function saveTrackToDB(key, file) {
            if (!idb) return;
            const tx = idb.transaction("tracks", "readwrite");
            tx.objectStore("tracks").put(file, key);
        }

        function saveVoiceToDB(file) {
            if (!idb) return;
            const tx = idb.transaction("voices", "readwrite");
            tx.objectStore("voices").add({ name: file.name, blob: file });
        }

        async function loadSavedAssets() {
            if (!idb) return;
            const tx = idb.transaction("tracks", "readonly");
            const store = tx.objectStore("tracks");

            ['intro', 'outro', 'bed'].forEach(type => {
                const req = store.get(type);
                req.onsuccess = async () => {
                    if (req.result) {
                        const file = req.result;
                        if (type === 'intro') currentIntroFile = file;
                        if (type === 'outro') currentOutroFile = file;

                        const buff = await loadAudioFile(file);
                        if (type === 'intro') { introBuffer = buff; $('introStatus').innerText = "Loaded: " + file.name; }
                        if (type === 'outro') { outroBuffer = buff; $('outroStatus').innerText = "Loaded: " + file.name; }
                        if (type === 'bed') { musicBuffer = buff; $('bedStatus').innerText = "Loaded: " + file.name; }
                    }
                };
            });

            // Voices
            const vTx = idb.transaction("voices", "readonly");
            const vStore = vTx.objectStore("voices");
            const vReq = vStore.getAll();
            vReq.onsuccess = async () => {
                const voices = vReq.result;
                if (voices && voices.length > 0) {
                    $('emptyMsg').style.display = 'none';
                    for (let v of voices) {
                        const buff = await loadAudioFile(v.blob);
                        if (buff) {
                            const id = voiceLibrary.length;
                            voiceLibrary.push({ name: v.name, buffer: buff });
                            addVoiceToUI(v.name, id, buff.duration);
                        }
                    }
                    if (voiceLibrary.length > 0) selectVoice(0);
                }
            };
        }

        // -- AUDIO HELPERS --
        reverbBuffer = createReverbImpulse(2.0);

        async function loadAudioFile(file) {
            if (!file) return null;
            const ab = await file.arrayBuffer();
            return await ctx.decodeAudioData(ab);
        }

        function findAudioStart(buffer) {
            const data = buffer.getChannelData(0);
            const threshold = 0.015;
            for (let i = 0; i < data.length; i++) {
                if (Math.abs(data[i]) > threshold) return i / buffer.sampleRate;
            }
            return 0;
        }

        function createReverbImpulse(duration) {
            const len = ctx.sampleRate * duration;
            const buffer = ctx.createBuffer(2, len, ctx.sampleRate);
            for (let c = 0; c < 2; c++) {
                const data = buffer.getChannelData(c);
                for (let i = 0; i < len; i++) {
                    const decay = Math.pow(1 - i / len, 3);
                    data[i] = (Math.random() * 2 - 1) * decay;
                }
            }
            return buffer;
        }

        // WAV Encoder - converts AudioBuffer to WAV Blob
        function audioBufferToWav(buffer) {
            const numChannels = buffer.numberOfChannels;
            const sampleRate = buffer.sampleRate;
            const format = 1; // PCM
            const bitDepth = 16;

            const bytesPerSample = bitDepth / 8;
            const blockAlign = numChannels * bytesPerSample;

            const samples = buffer.length;
            const dataSize = samples * blockAlign;
            const bufferSize = 44 + dataSize;

            const arrayBuffer = new ArrayBuffer(bufferSize);
            const view = new DataView(arrayBuffer);

            // WAV header
            const writeString = (offset, string) => {
                for (let i = 0; i < string.length; i++) {
                    view.setUint8(offset + i, string.charCodeAt(i));
                }
            };

            writeString(0, 'RIFF');
            view.setUint32(4, bufferSize - 8, true);
            writeString(8, 'WAVE');
            writeString(12, 'fmt ');
            view.setUint32(16, 16, true); // fmt chunk size
            view.setUint16(20, format, true);
            view.setUint16(22, numChannels, true);
            view.setUint32(24, sampleRate, true);
            view.setUint32(28, sampleRate * blockAlign, true);
            view.setUint16(32, blockAlign, true);
            view.setUint16(34, bitDepth, true);
            writeString(36, 'data');
            view.setUint32(40, dataSize, true);

            // Interleave channels and write samples
            const channels = [];
            for (let c = 0; c < numChannels; c++) {
                channels.push(buffer.getChannelData(c));
            }

            let offset = 44;
            for (let i = 0; i < samples; i++) {
                for (let c = 0; c < numChannels; c++) {
                    let sample = channels[c][i];
                    sample = Math.max(-1, Math.min(1, sample));
                    sample = sample < 0 ? sample * 0x8000 : sample * 0x7FFF;
                    view.setInt16(offset, sample, true);
                    offset += 2;
                }
            }

            return new Blob([arrayBuffer], { type: 'audio/wav' });
        }

        function addVoiceToUI(name, id, duration) {
            const list = $('voiceList');
            const li = document.createElement('li');
            li.className = 'voice-item';
            li.innerHTML = `<span>${name}</span> <span style="font-size:0.7rem; color:#666">${duration.toFixed(1)}s</span>`;
            li.onclick = () => selectVoice(id);
            li.dataset.id = id;
            list.appendChild(li);
        }

        function selectVoice(idx) {
            selectedVoiceIndex = idx;
            document.querySelectorAll('.voice-item').forEach(el => el.classList.remove('active'));
            // Simplified visual selection update
            const items = document.querySelectorAll('.voice-item');
            for (let i = 0; i < items.length; i++) {
                if (items[i].dataset.id == idx) {
                    items[i].classList.add('active');
                    break;
                }
            }
            if (voiceLibrary[idx]) $('selectedVoiceName').textContent = voiceLibrary[idx].name;
        }

        // -- EVENT LISTENERS --
        $('voiceUploader').addEventListener('change', async (e) => {
            const files = Array.from(e.target.files);
            if (!files.length) return;
            $('emptyMsg').style.display = 'none';
            for (let file of files) {
                saveVoiceToDB(file);
                const buff = await loadAudioFile(file);
                if (buff) {
                    const id = voiceLibrary.length;
                    voiceLibrary.push({ name: file.name, buffer: buff });
                    addVoiceToUI(file.name, id, buff.duration);
                }
            }
            if (selectedVoiceIndex === -1 && voiceLibrary.length > 0) selectVoice(0);
        });

        $('introFile').addEventListener('change', async (e) => {
            const f = e.target.files[0]; if (!f) return;
            currentIntroFile = f;
            saveTrackToDB("intro", f);
            introBuffer = await loadAudioFile(f);
            $('introStatus').innerText = "Loaded: " + f.name;
        });

        $('outroFile').addEventListener('change', async (e) => {
            const f = e.target.files[0]; if (!f) return;
            currentOutroFile = f;
            saveTrackToDB("outro", f);
            outroBuffer = await loadAudioFile(f);
            $('outroStatus').innerText = "Loaded: " + f.name;
        });

        $('bedFile').addEventListener('change', async (e) => {
            const f = e.target.files[0]; if (!f) return;
            saveTrackToDB("bed", f);
            musicBuffer = await loadAudioFile(f);
            $('bedStatus').innerText = "Loaded: " + f.name;
        });

        // CLOUD UPLOAD HANDLERS
        $('uploadIntroBtn').onclick = () => {
            if (currentIntroFile) uploadToCloud(currentIntroFile, 'intro');
            else alert("No Intro file loaded locally.");
        };
        $('uploadOutroBtn').onclick = () => {
            if (currentOutroFile) uploadToCloud(currentOutroFile, 'outro');
            else alert("No Outro file loaded locally.");
        };

        // -- SEQUENCER --
        $('generateBtn').addEventListener('click', async () => {
            if (ctx.state === 'suspended') await ctx.resume();
            if (selectedVoiceIndex === -1) { alert("Select a voice!"); return; }

            const btn = $('generateBtn');
            const status = $('statusText');
            const progress = $('progressBar');

            btn.disabled = true;
            status.textContent = "Rendering...";
            progress.style.width = "0%";

            const masterComp = ctx.createDynamicsCompressor();
            masterComp.threshold.value = -12; masterComp.knee.value = 30; masterComp.ratio.value = 4; masterComp.attack.value = 0.003; masterComp.release.value = 0.25;
            const masterGain = ctx.createGain(); masterGain.gain.value = 1.0;
            masterComp.connect(masterGain); masterGain.connect(ctx.destination); masterGain.connect(dest);

            audioChunks = [];
            recorder = new MediaRecorder(dest.stream);
            recorder.ondataavailable = e => audioChunks.push(e.data);
            recorder.start();

            const t0 = ctx.currentTime + 0.2;
            const introDur = introBuffer ? introBuffer.duration : 0;
            const voiceObj = voiceLibrary[selectedVoiceIndex];
            const cuePoint = findAudioStart(voiceObj.buffer);

            const pitchSemis = parseInt($('voicePitch').value);
            const pitchRate = Math.pow(2, pitchSemis / 12);

            const introOffset = parseFloat($('voiceOffset').value);
            const outroOffset = parseFloat($('outroOffset').value);
            const endTrim = parseFloat($('endTrim').value);

            const buildUpOn = $('buildUpOn').checked;
            const widthOn = $('widthOn').checked;
            const tailOn = $('tailOn').checked;

            const stutterCount = 4; const stutterLen = 0.150;
            const buildUpDur = buildUpOn ? (stutterCount * stutterLen) : 0;
            const rawVoiceDur = (voiceObj.buffer.duration - cuePoint) / pitchRate;
            const totalVoiceSectionDur = buildUpDur + rawVoiceDur;

            // TIMELINE
            const timeIntro = t0;
            let timeVoice = t0 + introOffset;
            if (timeVoice < t0) timeVoice = t0;
            const absVoiceStart = timeVoice + buildUpDur;
            const timeOutro = timeVoice + totalVoiceSectionDur + outroOffset;

            // Intro
            if (introBuffer) {
                const src = ctx.createBufferSource(); src.buffer = introBuffer;
                const g = ctx.createGain(); g.gain.value = $('introVol').value;
                src.connect(g).connect(masterComp); src.start(timeIntro);
            }

            // Music Bed
            let bedNode, bedGain;
            if (musicBuffer) {
                bedNode = ctx.createBufferSource(); bedNode.buffer = musicBuffer;
                bedGain = ctx.createGain(); bedGain.gain.setValueAtTime(parseFloat($('bedVol').value), t0);
                bedNode.connect(bedGain).connect(masterComp); bedNode.start(t0);
            }

            // Voice
            const voiceVol = parseFloat($('voiceVol').value);
            if (buildUpOn) {
                const bg = ctx.createGain(); bg.gain.value = voiceVol;
                const dly = ctx.createDelay(); dly.delayTime.value = 0.005;
                const lfo = ctx.createOscillator(); lfo.frequency.value = 3;
                const dep = ctx.createGain(); dep.gain.value = 0.002;
                lfo.connect(dep).connect(dly.delayTime); lfo.start(t0);
                const hpf = ctx.createBiquadFilter(); hpf.type = 'highpass';
                hpf.frequency.setValueAtTime(200, timeVoice); hpf.frequency.exponentialRampToValueAtTime(1000, timeVoice + buildUpDur);
                hpf.connect(dly).connect(bg).connect(masterComp);

                const startP = -300; const endP = 0;
                for (let i = 0; i < stutterCount; i++) {
                    const s = ctx.createBufferSource(); s.buffer = voiceObj.buffer;
                    const p = i / (stutterCount - 1);
                    s.detune.value = (startP + (p * (endP - startP))) + (pitchSemis * 100);
                    s.connect(hpf); s.start(timeVoice + (i * stutterLen), cuePoint, stutterLen);
                }
            }

            const main = ctx.createBufferSource(); main.buffer = voiceObj.buffer;
            main.detune.value = pitchSemis * 100;
            let head = main;

            if (widthOn) {
                const pEQ = ctx.createBiquadFilter(); pEQ.type = 'peaking'; pEQ.frequency.value = 3000; pEQ.gain.value = 4;
                const aEQ = ctx.createBiquadFilter(); aEQ.type = 'highshelf'; aEQ.frequency.value = 10000; aEQ.gain.value = 5;
                main.connect(pEQ).connect(aEQ); head = aEQ;

                // Width FX
                const wAmt = parseFloat($('widthAmt').value);
                if (wAmt > 0) {
                    const wg = ctx.createGain(); wg.gain.value = wAmt * 0.6;
                    const sL = ctx.createBufferSource(); sL.buffer = voiceObj.buffer; sL.detune.value = (pitchSemis * 100) - 12;
                    const sR = ctx.createBufferSource(); sR.buffer = voiceObj.buffer; sR.detune.value = (pitchSemis * 100) + 12;
                    const dL = ctx.createDelay(); dL.delayTime.value = 0.018; const pL = ctx.createStereoPanner(); pL.pan.value = -1;
                    const dR = ctx.createDelay(); dR.delayTime.value = 0.028; const pR = ctx.createStereoPanner(); pR.pan.value = 1;
                    sL.connect(dL).connect(pL).connect(wg); sR.connect(dR).connect(pR).connect(wg); wg.connect(masterComp);
                    sL.start(absVoiceStart, cuePoint); sR.start(absVoiceStart, cuePoint);
                }
            }

            const vg = ctx.createGain(); vg.gain.value = voiceVol;
            head.connect(vg).connect(masterComp);

            if (tailOn) {
                const startPct = parseFloat($('tailStart').value);
                const mix = parseFloat($('tailMix').value);
                const ts = ctx.createGain(); ts.gain.value = 0;
                const dL = ctx.createDelay(); dL.delayTime.value = 0.3; const dR = ctx.createDelay(); dR.delayTime.value = 0.45;
                const fbL = ctx.createGain(); fbL.gain.value = 0.4; const fbR = ctx.createGain(); fbR.gain.value = 0.4;
                const m = ctx.createChannelMerger(2);
                ts.connect(dL); ts.connect(dR); dL.connect(fbL).connect(dR); dR.connect(fbR).connect(dL);
                dL.connect(m, 0, 0); dR.connect(m, 0, 1);
                const rev = ctx.createConvolver(); rev.buffer = reverbBuffer;
                m.connect(masterComp); ts.connect(rev).connect(masterComp); vg.connect(ts);
                const tStart = absVoiceStart + (rawVoiceDur * startPct);
                ts.gain.setValueAtTime(0, tStart); ts.gain.linearRampToValueAtTime(mix, absVoiceStart + rawVoiceDur);
            }
            main.start(absVoiceStart, cuePoint);

            // Outro
            if (outroBuffer) {
                const src = ctx.createBufferSource(); src.buffer = outroBuffer;
                const g = ctx.createGain(); g.gain.value = $('outroVol').value;
                src.connect(g).connect(masterComp);
                let start = timeOutro; if (start < t0) start = t0;
                src.start(start);
            }

            // Ducking
            if (musicBuffer && $('autoDuck').checked) {
                const start = timeVoice; const end = timeOutro; const v = parseFloat($('bedVol').value);
                bedGain.gain.setValueAtTime(v, start); bedGain.gain.linearRampToValueAtTime(v * 0.3, start + 0.3);
                bedGain.gain.setValueAtTime(v * 0.3, end); bedGain.gain.linearRampToValueAtTime(v, end + 1.0);
            }

            // Cleanup
            progress.style.width = "100%";
            const endIntro = timeIntro + (introBuffer ? introBuffer.duration : 0);
            let realOutroStart = timeOutro; if (realOutroStart < t0) realOutroStart = t0;
            const endOutro = realOutroStart + (outroBuffer ? outroBuffer.duration : 0);
            const naturalEnd = Math.max(endIntro, endOutro);

            let fadeStart = naturalEnd + endTrim;
            if (fadeStart < t0) fadeStart = t0 + 1;

            masterGain.gain.setValueAtTime(1, fadeStart);
            masterGain.gain.linearRampToValueAtTime(0, fadeStart + 2.0);

            const stopTime = fadeStart + 2.1;
            setTimeout(() => {
                recorder.stop();
                if (bedNode) bedNode.stop(ctx.currentTime + 0.1);
                btn.disabled = false; status.textContent = "Done!"; $('downloadBtn').disabled = false; progress.style.width = "0%";
            }, (stopTime - t0) * 1000);
        });

        $('downloadBtn').onclick = async () => {
            const webmBlob = new Blob(audioChunks, { type: 'audio/webm' });
            try {
                // Decode the WebM to AudioBuffer, then encode as WAV
                const arrayBuffer = await webmBlob.arrayBuffer();
                const audioBuffer = await ctx.decodeAudioData(arrayBuffer);
                const wavBlob = audioBufferToWav(audioBuffer);

                // Try to use modern File System Access API for Save As dialog
                if ('showSaveFilePicker' in window) {
                    try {
                        const handle = await window.showSaveFilePicker({
                            suggestedName: `dj-drop-${Date.now()}.wav`,
                            types: [{
                                description: 'WAV Audio',
                                accept: { 'audio/wav': ['.wav'] }
                            }]
                        });
                        const writable = await handle.createWritable();
                        await writable.write(wavBlob);
                        await writable.close();
                        alert('File saved successfully!');
                        return;
                    } catch (err) {
                        if (err.name === 'AbortError') return; // User cancelled
                        console.warn('Save dialog failed, using fallback:', err);
                    }
                }

                // Fallback for browsers without File System Access API
                const url = URL.createObjectURL(wavBlob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `dj-drop-${Date.now()}.wav`;
                a.click();
            } catch (e) {
                console.error('WAV conversion failed, falling back to WebM:', e);
                // Fallback to WebM if conversion fails
                const url = URL.createObjectURL(webmBlob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `dj-drop-${Date.now()}.webm`;
                a.click();
            }
        };
    </script>
</body>

</html>